# [返回首页](./../README.md)

<!-- 
* redis是单线程还是多线程，如何使redis和数据库数据同步
  4.0之前单线程，之后多线程；先删除缓存，后更新数据库（数据库同步redis） -->

&emsp;&emsp; Redis，英文全称是Remote Dictionary Server（远程字典服务），是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。

&emsp;&emsp; 与MySQL数据库不同的是，Redis的数据是存在内存中的。它的读写速度非常快，每秒可以处理超过10万次读写操作。因此redis被广泛应用于缓存，另外，Redis也经常用来做分布式锁。除此之外，Redis支持事务、持久化、LUA 脚本、LRU 驱动事件、多种集群方案。


## Redis 五种基本数据结构类型

* String（字符串）
* Hash（哈希）
* List（列表）
* Set（集合）
* zset（有序集合）

## 三种特殊数据结构类型
* Geospatial
* Hyperloglog
* Bitmap


## 数据类型使用场景

### String（字符串）
* 简介:String是Redis最基础的数据结构类型，它是二进制安全的，可以存储图片或者序列化的对象，值最大存储为512M
* 简单使用举例: set key value、get key等
* 应用场景：共享session、分布式锁，计数器、限流。
* 内部编码有3种，int（8字节长整型）/embstr（小于等于39字节字符串）/raw（大于39个字节字符串）


### Hash（哈希）
* 简介：在Redis中，哈希类型是指v（值）本身又是一个键值对（k-v）结构,特别适合缓存对象。
* 简单使用举例：hset key field value 、hget key field
* 内部编码：ziplist（压缩列表） 、hashtable（哈希表）
* 应用场景：缓存用户信息等。
* 注意点：如果开发使用hgetall，哈希元素比较多的话，可能导致Redis阻塞，可以使用hscan。而如果只是获取部分field，建议使用hmget。


### List（列表）
* 简介：列表（list）类型是用来存储多个有序的字符串，一个列表最多可以存储2^32-1个元素。
* 简单实用举例：lpush key value [value ...] 、lrange key start end
* 内部编码：ziplist（压缩列表）、linkedlist（链表）
* 应用场景：消息队列，文章列表


### Set（集合）
* 简介：集合（set）类型也是用来保存多个字符串元素，**但是不允许重复元素**
* 简单使用举例：sadd key element [element ...]、smembers key
* 内部编码：intset（整数集合）、hashtable（哈希表）
* 注意点：smembers和lrange、hgetall都属于比较重的命令，如果元素过多存在阻塞Redis的可能性，可以使用sscan来完成。
* 应用场景：用户标签,生成随机数抽奖、社交需求。

### 有序集合（zset）
* 简介：已排序的字符串集合，同时元素不能重复
* 简单格式举例：zadd key score member [score member ...]，zrank key member
* 底层内部编码：ziplist（压缩列表）、skiplist（跳跃表）
* 应用场景：排行榜，社交需求（如用户点赞）。

### Redis 的三种特殊数据类型
* Geo：Redis3.2推出的，地理位置定位，用于存储地理位置信息，并对存储的信息进行操作。
* HyperLogLog：用来做基数统计算法的数据结构，如统计网站的UV。
* Bitmaps ：用一个比特位来映射某个元素的状态，在Redis中，它的底层是基于字符串类型实现的，可以把bitmaps成作一个以比特位为单位的数组

## 单线程模型
* Redis是单线程模型的，而单线程避免了CPU不必要的上下文切换和竞争锁的消耗。也正因为是单线程，如果某个命令执行过长（如hgetall命令），会造成阻塞。Redis是面向快速执行场景的数据库。，所以要慎用如smembers和lrange、hgetall等命令。

* Redis 6.0 引入了多线程提速，它的执行命令操作内存的仍然是个单线程。


## 虚拟内存机制
&emsp;&emsp; Redis直接自己构建了VM机制 ，不会像一般的系统会调用系统函数处理，会浪费一定的时间去移动和请求。

* Redis的虚拟内存机制是啥呢？
> 虚拟内存机制就是暂时把不经常访问的数据(冷数据)从内存交换到磁盘中，从而腾出宝贵的内存空间用于其它需要访问的数据(热数据)。通过VM功能可以实现冷热数据分离，使热数据仍在内存中、冷数据保存到磁盘。这样就可以避免因为内存不足而造成访问速度下降的问题。


##  什么是缓存击穿、缓存穿透、缓存雪崩？

* 缓存穿透
  <br/>指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，进而给数据库带来压力。
  
  <p>缓存穿透一般都是这几种情况产生的：</p>

  1、业务不合理的设计，比如大多数用户都没开守护，但是你的每个请求都去缓存，查询某个userid查询有没有守护。

  2、业务/运维/开发失误的操作，比如缓存和数据库的数据都被误删除了。

  3、黑客非法请求攻击，比如黑客故意捏造大量非法请求，以读取不存在的业务数据。
  
* 缓存雪奔
  <br/>指缓存中数据大批量到过期时间，而查询数据量巨大，请求都直接访问数据库，引起数据库压力过大甚至down机。

  <br/>缓存雪奔一般是由于大量数据同时过期造成的，对于这个原因，可通过均匀设置过期时间解决，即让过期时间相对离散一点。如采用一个较大固定值+一个较小的随机值，5小时+0到1800秒这样。
  Redis 故障宕机也可能引起缓存雪奔。这就需要构造Redis高可用集群。

* 缓存击穿
  <br/>指热点key在某个时间点过期的时候，而恰好在这个时间点对这个Key有大量的并发请求过来，从而大量的请求打到db。

缓存击穿和缓存雪崩看着有点像，其实它两区别是，缓存雪奔是指数据库压力过大甚至down机，缓存击穿只是大量并发请求到了DB数据库层面。可以认为击穿是缓存雪奔的一个子集吧。有些文章认为它俩区别，是区别在于击穿针对某一热点key缓存，雪奔则是很多key

<br/>解决方案就有两种：
<br/>1.使用互斥锁方案。缓存失效时，不是立即去加载db数据，而是先使用某些带成功返回的原子操作命令，如(Redis的setnx）去操作，成功的时候，再去加载db数据库数据和设置缓存。否则就去重试获取缓存。
<br/>2. “永不过期”，是指没有设置过期时间，但是热点数据快要过期时，异步线程去更新和设置过期时间。

## Redis 集群

Redis 高可用三种部署方式：主从模式，哨兵模式，集群模式

### 主从模式

&emsp;&emsp;主从模式中，Redis部署了多台机器，有主节点，负责读写操作，有从节点，只负责读操作。从节点的数据来自主节点，实现原理就是主从复制机制

&emsp;&emsp;主从复制包括全量复制，增量复制两种。一般当slave第一次启动连接master，或者认为是第一次连接，就采用全量复制


<strong>全量复制流程：</strong>
* 1.slave发送sync命令到master。
* 2.master接收到SYNC命令后，执行bgsave命令，生成RDB全量文件。
* 3.master使用缓冲区，记录RDB快照生成期间的所有写命令。
* 4.master执行完bgsave后，向所有slave发送RDB快照文件。
* 5.slave收到RDB快照文件后，载入、解析收到的快照。
* 6.master使用缓冲区，记录RDB同步期间生成的所有写的命令。
* 7.master快照发送完毕后，开始向slave发送缓冲区中的写命令;
* 8.salve接受命令请求，并执行来自master缓冲区的写命令

> redis2.8版本之后，已经使用psync来替代sync，因为sync命令非常消耗系统资源，psync的效率更高。

> slave与master全量同步之后，master上的数据，如果再次发生更新，就会触发增量复制。

> 当master节点发生数据增减时，就会触发replicationFeedSalves()函数，接下来在 Master节点上调用的每一个命令会使用replicationFeedSlaves()来同步到Slave节点。执行此函数之前呢，master节点会判断用户执行的命令是否有数据更新，如果有数据更新的话，并且slave节点不为空，就会执行此函数。这个函数作用就是：把用户执行的命令发送到所有的slave节点，让slave节点执行。


### 哨兵模式

&emsp;&emsp; 主从模式中，一旦主节点由于故障不能提供服务，需要人工将从节点晋升为主节点，同时还要通知应用方更新主节点地址。显然，多数业务场景都不能接受这种故障处理方式。Redis从2.8开始正式提供了Redis Sentinel（哨兵）架构来解决这个问题。

&emsp;&emsp; <b>哨兵模式</b>，由一个或多个Sentinel实例组成的Sentinel系统，它可以监视所有的Redis主节点和从节点，并在被监视的主节点进入下线状态时，自动将下线主服务器属下的某个从节点升级为新的主节点。但是呢，一个哨兵进程对Redis节点进行监控，就可能会出现问题（单点问题），因此，可以使用多个哨兵来进行监控Redis节点，并且各个哨兵之间还会进行监控。


![](/public/image/redis/sentinel.jpg)

</br>

> 简单来说，哨兵模式就三个作用：</br>
发送命令，等待Redis服务器（包括主服务器和从服务器）返回监控其运行状态；
哨兵监测到主节点宕机，会自动将从节点切换成主节点，然后通过发布订阅模式通知其他的从节点，修改配置文件，让它们切换主机；
哨兵之间还会相互监控，从而达到高可用。

<br>
<b>故障切换的过程是怎样的呢</b>

&emsp;&emsp; 假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行 failover 过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行 failover 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。这样对于客户端而言，一切都是透明的。

<br>
<b>哨兵的工作模式如下：</b>

*  每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他Sentinel实例发送一个 PING命令。
* 如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel标记为主观下线。
* 如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态。
* 当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线。
* 在一般情况下， 每个 Sentinel 会以每10秒一次的频率向它已知的所有Master，Slave发送 INFO 命令。
* 当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次
* 若没有足够数量的 Sentinel同意Master已经下线， Master的客观下线状态就会被移除；若Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。

### Cluster集群模式

&emsp;&emsp;  哨兵模式基于主从模式，实现读写分离，它还可以自动切换，系统可用性更高。但是它每个节点存储的数据是一样的，浪费内存，并且不好在线扩容。因此，Cluster集群应运而生，它在Redis3.0加入的，实现了Redis的分布式存储。对数据进行分片，也就是说每台Redis节点上存储不同的内容，来解决在线扩容的问题。并且，它也提供复制和故障转移的功能。

#### Cluster集群节点的通讯

&emsp;&emsp;  一个Redis集群由多个节点组成，各个节点之间是怎么通信的呢？通过Gossip  [ˈɡɑːsɪp] 协议！

&emsp;&emsp;  Redis Cluster集群通过Gossip协议进行通信，节点之间不断交换信息，交换的信息内容包括节点出现故障、新节点加入、主从节点变更信息、slot信息等等。常用的Gossip消息分为4种，分别是：ping、pong、meet、fail。
![](/public/image/redis/Gossip.jpg)



> * meet消息：通知新节点加入。消息发送者通知接收者加入到当前集群，meet消息通信正常完成后，接收节点会加入到集群中并进行周期性的ping、pong消息交换。
> * ping消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送ping消息，用于检测节点是否在线和交换彼此状态信息。
> * pong消息：当接收到ping、meet消息时，作为响应消息回复给发送方确认消息正常通信。pong消息内部封装了自身状态数据。节点也可以向集群内广播自身的pong消息来通知整个集群对自身状态进行更新。
> * fail消息：当节点判定集群内另一个节点下线时，会向集群内广播一个fail消息，其他节点接收到fail消息之后把对应节点更新为下线状态。

> 特别的是，每个节点是通过集群总线(cluster bus) 与其他的节点进行通信的。通讯时，使用特殊的端口号，即对外服务端口号加10000。例如如果某个node的端口号是6379，那么它与其它nodes通信的端口号是 16379。nodes 之间的通信采用特殊的二进制协议。

#### Hash Slot插槽算法

&emsp;&emsp;  既然是分布式存储，Cluster集群使用的分布式算法是一致性Hash嘛？并不是，而是Hash Slot插槽算法。

&emsp;&emsp;  插槽算法把整个数据库被分为16384个slot（槽），每个进入Redis的键值对，根据key进行散列，分配到这16384插槽中的一个。使用的哈希映射也比较简单，用CRC16算法计算出一个16 位的值，再对16384取模。数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点都可以处理这16384个槽。

&emsp;&emsp;  集群中的每个节点负责一部分的hash槽，比如当前集群有A、B、C个节点，每个节点上的哈希槽数 =16384/3，那么就有：

> 节点A负责0~5460号哈希槽
> 
> 节点B负责5461~10922号哈希槽
> 
> 节点C负责10923~16383号哈希槽


## 使用过Redis分布式锁嘛？有哪些注意点呢？

&emsp;&emsp;  <strong>分布式锁</strong>，是控制分布式系统不同进程共同访问共享资源的一种锁的实现。秒杀下单、抢红包等等业务场景，都需要用到分布式锁，我们项目中经常使用Redis作为分布式锁。

## 为什么Redis 6.0 之后改多线程呢？


&emsp;&emsp; redis6.0之前，Redis在处理客户端的请求时，包括读socket、解析、执行、写socket等都由一个顺序串行的主线程处理，这就是所谓的“单线程”。

&emsp;&emsp; Redis6.0之前为什么一直不使用多线程？使用Redis时，几乎不存在CPU成为瓶颈的情况， Redis主要受限于内存和网络。例如在一个普通的Linux系统上，Redis通过使用pipelining每秒可以处理100万个请求，所以如果应用程序主要使用O(N)或O(log(N))的命令，它几乎不会占用太多CPU。

&emsp;&emsp; redis使用多线程并非是完全摒弃单线程，redis还是使用单线程模型来处理客户端的请求，只是使用多线程来处理数据的读写和协议解析，执行命令还是使用单线程。
这样做的目的是因为redis的性能瓶颈在于网络IO而非CPU，使用多线程能提升IO读写的效率，从而整体提高redis的性能。

## 在生成 RDB期间，Redis 可以同时处理写请求么？

&emsp;&emsp;可以的，Redis提供两个指令生成RDB，分别是save和bgsave。

>如果是save指令，会阻塞，因为是主线程执行的。
>
>如果是bgsave指令，是fork一个子进程来写入RDB文件的，快照持久化完全交给子进程来处理，父进程则可以继续处理客户端的请求。

## Redis 为什么这么快
* 基于内存实现
* 高效的数据结构
* 合理的数据编码，不同场景使用不同的数据类型
* 合理的线程模型，单线程模型避免上下文切换，I/O多路复用
* 虚拟内存机制


## 参考文献：
* [20道Redis经典面试题！（珍藏版）](https://zhuanlan.zhihu.com/p/427496556)
* [Redis系列九：redis集群高可用](https://www.cnblogs.com/leeSmall/p/8414687.html)
* [Redis面试题及答案整理（2021年Redis面试题大汇总）](https://zhuanlan.zhihu.com/p/398598274)
  